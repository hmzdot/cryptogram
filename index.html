<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cryptogram Game</title>
    <link rel="manifest" href="/cryptogram/manifest.json" />
    <meta name="theme-color" content="#34495e" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-mobile-web-app-title" content="Cryptogram" />
    <link rel="apple-touch-icon" href="/cryptogram/icons/icon-192x192.png" />
    <!-- iOS splash screen images -->
    <link
      rel="apple-touch-startup-image"
      href="/cryptogram/icons/icon-512x512.png"
      media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"
    />
    <link
      rel="apple-touch-startup-image"
      href="/cryptogram/icons/icon-512x512.png"
      media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)"
    />
    <link
      rel="apple-touch-startup-image"
      href="/cryptogram/icons/icon-512x512.png"
      media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3)"
    />
    <link
      rel="apple-touch-startup-image"
      href="/cryptogram/icons/icon-512x512.png"
      media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f4f8;
        color: #2c3e50;
      }
      h1 {
        color: #34495e;
        text-align: center;
        margin-bottom: 30px;
      }
      .controls {
        text-align: center;
        margin-bottom: 30px;
      }
      .cryptogram {
        margin: 20px 0;
        font-size: 24px;
        letter-spacing: 2px;
        background-color: #ffffff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        align-items: center;
        text-align: center;
      }
      .word {
        display: flex;
        align-items: center;
        gap: 2px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .word-container {
        display: flex;
        justify-content: center;
        margin: 4px 0;
      }
      .letter {
        display: inline-block;
        text-align: center;
        margin: 0 2px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .punctuation {
        height: 30px;
        line-height: 100%;
        margin-bottom: 5px;
        transform: translateY(-0.5em);
      }
      .hyphen {
        margin-right: 2px;
        color: #666;
      }
      input {
        width: 28px;
        height: 28px;
        text-align: center;
        font-size: 16px;
        margin-bottom: 5px;
        display: block;
        border: 2px solid #bdc3c7;
        border-radius: 5px;
        background-color: #fff;
        transition: all 0.3s ease;
      }
      input:focus {
        outline: none;
        border-color: #95a5a6;
        box-shadow: 0 0 5px rgba(149, 165, 166, 0.5);
      }
      button {
        padding: 12px 24px;
        font-size: 16px;
        /* margin: 10px 5px; */
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        background-color: #a8d8ea;
        color: #2c3e50;
      }
      button:hover {
        background-color: #aa96da;
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      button:active {
        transform: translateY(0);
      }
      input[style*="color: red"] {
        background-color: #ffcdd2;
        border-color: #ef9a9a;
      }
      input[style*="color: green"] {
        background-color: #c8e6c9;
        border-color: #a5d6a7;
      }
      input[style*="color: blue"] {
        background-color: #bbdefb;
        border-color: #90caf9;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      /* Mobile-specific styles */
      @media (max-width: 600px) {
        body {
          padding: 10px;
        }
        h1 {
          font-size: 24px;
          margin-bottom: 20px;
        }
        .cryptogram {
          font-size: 20px;
          padding: 15px;
          gap: 6px;
        }
        input {
          width: 24px;
          height: 24px;
          font-size: 14px;
        }
        button {
          padding: 10px 20px;
          font-size: 14px;
          flex: 1 1 calc(50% - 10px);
          min-width: 120px;
          max-width: 200px;
        }
        .word {
          gap: 1px;
        }
        .letter {
          margin: 0 1px;
        }
      }
      .install-prompt {
        display: none;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(52, 73, 94, 0.95);
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        font-size: 14px;
        text-align: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
      }
      #debug {
        position: fixed;
        top: 10px;
        right: 10px;
        width: 300px;
        max-height: 200px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff00;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
        z-index: 1000;
      }
      @media (max-width: 600px) {
        #debug {
          width: calc(100% - 40px);
          max-height: 150px;
        }
      }
    </style>
    <script src="quotes.js"></script>
    <script>
      // Enhanced logging system
      const logger = {
        info: function (...args) {
          console.log("â„¹ï¸", ...args);
        },
        error: function (...args) {
          console.log("âŒ", ...args);
        },
        success: function (...args) {
          console.log("âœ…", ...args);
        },
        warn: function (...args) {
          console.log("âš ï¸", ...args);
        },
      };

      // Global error handler
      window.onerror = function (msg, url, lineNo, columnNo, error) {
        logger.error("Uncaught Error:", msg);
        if (error && error.stack) {
          logger.error("Stack:", error.stack);
        }
        return false;
      };

      // Unhandled promise rejection handler
      window.addEventListener("unhandledrejection", function (event) {
        logger.error("Unhandled Promise Rejection:", event.reason);
      });

      // Show installation prompt for iOS users
      if (
        navigator.userAgent.match(/iPhone|iPad|iPod/) &&
        !navigator.standalone
      ) {
        setTimeout(() => {
          logger.info("Showing iOS installation prompt");
          document.getElementById("installPrompt").style.display = "block";
        }, 2000);
      }

      // Register Service Worker
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          logger.info("Attempting to register service worker...");
          navigator.serviceWorker
            .register("/cryptogram/sw.js", { scope: "/cryptogram/" })
            .then((registration) => {
              logger.success("ServiceWorker registration successful:", {
                scope: registration.scope,
              });
            })
            .catch((err) => {
              logger.error("ServiceWorker registration failed:", err);
            });
        });
      } else {
        logger.warn("Service workers are not supported");
      }
    </script>
  </head>
  <body>
    <div id="installPrompt" class="install-prompt">
      iOS kullanÄ±cÄ±larÄ±: Ana ekrana eklemek iÃ§in Safari'de paylaÅŸ butonuna ðŸ“±
      tÄ±klayÄ±n ve "Ana Ekrana Ekle"yi seÃ§in
      <button
        onclick="this.parentElement.style.display='none'"
        style="
          background: white;
          color: #34495e;
          border: none;
          padding: 5px 10px;
          margin-left: 10px;
          border-radius: 5px;
        "
      >
        Tamam
      </button>
    </div>
    <pre id="debug"></pre>
    <h1><span id="title">Kriptogram BulmacasÄ±</span></h1>
    <div class="controls">
      <button onclick="newGame()">Yeni Oyun</button>
      <button onclick="checkSolution()">CevabÄ± Kontrol Et</button>
      <button onclick="giveHint()">Ä°pucu</button>
      <button onclick="revealSolution()">Ã‡Ã¶zÃ¼mÃ¼ GÃ¶ster</button>
      <button onclick="cleanInputs()">Temizle</button>
    </div>
    <div id="cryptogram" class="cryptogram"></div>

    <script>
      function getQuote() {
        return new Promise(async (resolve) => {
          try {
            // Verify that quotesData exists and contains at least one quote.
            if (!window.quotesData || quotesData.length === 0) {
              throw new Error("No quotes data found.");
            }
            // Optionally, select a random quote rather than always the first one.
            const randomIndex = Math.floor(Math.random() * quotesData.length);
            const englishQuote = quotesData[randomIndex].q;

            // Translate to Turkish using Google Translate API
            const translateResponse = await fetch(
              "https://translate.googleapis.com/translate_a/single",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded",
                },
                body: new URLSearchParams({
                  client: "gtx",
                  sl: "en",
                  tl: "tr",
                  dt: "t",
                  q: englishQuote,
                }),
              }
            );

            const translationData = await translateResponse.json();
            const turkishQuote = translationData[0][0][0];
            resolve(turkishQuote);
          } catch (error) {
            const fallbackQuotes = [
              "Ä°nsan ne olduÄŸunu bilmek istiyorsa, Ã¶nce ne olmadÄ±ÄŸÄ±nÄ± gÃ¶rmek zorunda.",
              "Hayat nedir ki,uzun bir ayrÄ±lÄ±k ezgisinden baÅŸka?",
              "Heyhat! Kim aÃ§Ä±klayabilir bize insan kalbi neden sevginin yanÄ±nda nefreti de barÄ±ndÄ±rÄ±r?",
              "BÃ¼yÃ¼mek acÄ± Ã§ekmek demekmiÅŸ, bunu iÃ§imi en sÄ±zlatan yanÄ±mdan Ã¶ÄŸrenmiÅŸtim",
              "Zaman, bize kim olduÄŸumuzu gÃ¶sterir.",
              "MÃ¼cahede kiÅŸinin kendisiyle savaÅŸÄ±dÄ±r, mÃ¼cadele baÅŸkasÄ±yla. Kendisiyle savaÅŸmayan baÅŸkasÄ±yla savaÅŸamaz",
            ];
            console.error("Error fetching or translating quote:", error);
            // Return a random fallback quote.
            resolve(
              fallbackQuotes[Math.floor(Math.random() * fallbackQuotes.length)]
            );
          }
        });
      }

      let currentQuote = "";
      let encryptedQuote = "";
      let solution = {};

      function initSolution() {
        logger.info("Initializing new solution...");
        const alphabet = "ABCÃ‡DEFGÄžHIÄ°JKLMNOÃ–PRSÅžTUÃœVYZ".split("");
        const numbers = Array.from(
          { length: alphabet.length },
          (_, i) => i + 1
        );
        for (let i = numbers.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
        }

        const cypher = {};
        solution = {};
        alphabet.forEach((letter, index) => {
          cypher[letter] = numbers[index];
          solution[numbers[index]] = letter;
        });
        logger.success("Solution initialized");
        return [cypher, solution];
      }

      function encrypt(text, cypher) {
        logger.info("Encrypting text:", text);
        text = text.toLocaleUpperCase();

        const result = text
          .split("")
          .map((char) => {
            const encrypted = cypher[char];
            return encrypted ?? char;
          })
          .join(" ");
        logger.success("Text encrypted");
        return result;
      }

      function createInput(letter) {
        // Handle spaces and punctuation
        if (!letter.match(/[0-9]/)) {
          const span = document.createElement("span");
          span.className = "punctuation";
          span.innerHTML = letter === " " ? "&nbsp;&nbsp;&nbsp;&nbsp;" : letter;
          return span;
        }
        const span = document.createElement("span");
        span.className = "letter";
        const input = document.createElement("input");
        input.maxLength = 1;
        input.dataset.encrypted = letter;
        input.addEventListener("input", (e) => {
          let value = e.target.value.toLocaleUpperCase();
          e.target.value = value;
          logger.info("Letter input:", { encrypted: letter, guess: value });

          // Fill in all inputs with the same encrypted number
          const sameLetterInputs = document.querySelectorAll(
            `input[data-encrypted="${letter}"]`
          );
          sameLetterInputs.forEach((input) => {
            input.value = value;
          });
        });
        span.appendChild(input);
        const encrypted = document.createElement("span");
        encrypted.textContent = letter;
        span.appendChild(encrypted);
        return span;
      }

      function splitWord(word, maxWidth) {
        // Create a temporary span to measure text width
        const measure = document.createElement("span");
        measure.style.visibility = "hidden";
        measure.style.position = "absolute";
        measure.style.fontSize = "20px"; // Match the mobile font size
        document.body.appendChild(measure);

        // Find the best splitting point (prefer splitting at vowels or consonants)
        const vowels = ["A", "E", "I", "Ä°", "O", "Ã–", "U", "Ãœ"];
        let bestSplit = Math.floor(word.length / 2);

        // Try to find a vowel near the middle to split at
        for (
          let i = Math.floor(word.length / 2) - 2;
          i < Math.floor(word.length / 2) + 2;
          i++
        ) {
          if (vowels.includes(word[i])) {
            bestSplit = i;
            break;
          }
        }

        const parts = [word.substring(0, bestSplit), word.substring(bestSplit)];

        document.body.removeChild(measure);
        return parts;
      }

      function calculateMaxWordLength() {
        // Calculate the width of a character from header
        // It has "Kriptogram BulmacasÄ±" text so we can calculate the width of
        // a character
        const maxWidth = document.body.clientWidth;
        const charLength = document.querySelector("#title").offsetWidth;
        const maxLength = Math.floor((maxWidth * 10) / charLength);
        return maxLength;
      }

      function createWordDiv(word, cypher) {
        const wordDiv = document.createElement("div");
        wordDiv.className = "word";

        const encryptedWord = encrypt(word, cypher);
        const chars = encryptedWord.split(" ");

        // Calculate if we need to split the word
        const maxLength = calculateMaxWordLength();
        if (word.length > maxLength) {
          // Threshold for splitting
          const parts = splitWord(word);
          const firstPart = encrypt(parts[0], cypher).split(" ");
          const secondPart = encrypt(parts[1], cypher).split(" ");

          // Create first part
          firstPart.forEach((char) => {
            wordDiv.appendChild(createInput(char));
          });

          // Add hyphen
          const hyphen = document.createElement("span");
          hyphen.textContent = "-";
          hyphen.className = "hyphen";
          wordDiv.appendChild(hyphen);

          // Force line break
          const lineBreak = document.createElement("div");
          lineBreak.style.flexBasis = "100%";
          lineBreak.style.height = "0";
          wordDiv.appendChild(lineBreak);

          // Create second part
          secondPart.forEach((char) => {
            wordDiv.appendChild(createInput(char));
          });
        } else {
          // Regular word processing
          chars.forEach((char) => {
            wordDiv.appendChild(createInput(char));
          });
        }

        return wordDiv;
      }

      async function newGame() {
        logger.info("Starting new game...");
        try {
          currentQuote = await getQuote();
          const [cypher, newSolution] = initSolution();
          solution = newSolution;
          const container = document.getElementById("cryptogram");
          container.innerHTML = "";

          const words = currentQuote.split(" ");
          logger.info("Creating puzzle with words:", words);

          words.forEach((word, index) => {
            const wordDiv = createWordDiv(word, cypher);
            container.appendChild(wordDiv);

            // Add space between words
            if (index < words.length - 1) {
              const spaceSpan = document.createElement("span");
              spaceSpan.innerHTML = "&nbsp;&nbsp;";
              container.appendChild(spaceSpan);
            }
          });
          logger.success("New game started successfully");
        } catch (error) {
          logger.error("Error starting new game:", error);
        }
      }

      function checkSolution() {
        logger.info("Checking solution...");
        const inputs = document.querySelectorAll("input");
        let correct = true;
        let totalChecked = 0;
        let correctCount = 0;

        inputs.forEach((input) => {
          const encrypted = input.dataset.encrypted;
          const userGuess = input.value.toLocaleUpperCase();
          const correctLetter = solution[encrypted];

          totalChecked++;
          if (userGuess !== correctLetter) {
            correct = false;
            input.style.color = "red";
          } else {
            correctCount++;
            input.style.color = "green";
          }
        });

        logger.info("Solution check results:", {
          totalLetters: totalChecked,
          correctLetters: correctCount,
          isComplete: correct,
        });

        if (correct) {
          logger.success("Puzzle solved correctly!");
          alert("Tebrikler! KriptogramÄ± Ã§Ã¶zdÃ¼nÃ¼z!");
        }
      }

      function revealSolution() {
        logger.info("Revealing solution...");
        const inputs = document.querySelectorAll("input");
        inputs.forEach((input) => {
          const encrypted = input.dataset.encrypted;
          input.value = solution[encrypted];
          input.style.color = "blue";
        });
        logger.success("Solution revealed");
      }

      function giveHint() {
        logger.info("Giving hint...");
        const inputs = Array.from(document.querySelectorAll("input"));
        // Filter for empty or incorrect inputs
        const unsolvedInputs = inputs.filter((input) => {
          const encrypted = input.dataset.encrypted;
          const userGuess = input.value.toLocaleUpperCase();
          const correctLetter = solution[encrypted];
          return !userGuess || userGuess !== correctLetter;
        });

        if (unsolvedInputs.length === 0) {
          logger.warn("No unsolved letters to hint");
          alert("TÃ¼m harfler zaten Ã§Ã¶zÃ¼lmÃ¼ÅŸ!");
          return;
        }

        // Pick a random unsolved input
        const randomInput =
          unsolvedInputs[Math.floor(Math.random() * unsolvedInputs.length)];
        const encrypted = randomInput.dataset.encrypted;
        const correctLetter = solution[encrypted];

        logger.info("Revealing hint for encrypted letter:", encrypted);

        // Fill in all instances of this letter
        const sameLetterInputs = document.querySelectorAll(
          `input[data-encrypted="${encrypted}"]`
        );
        sameLetterInputs.forEach((input) => {
          input.value = correctLetter;
          input.style.color = "blue";
        });
        logger.success("Hint provided for letter:", correctLetter);
      }

      function cleanInputs() {
        logger.info("Cleaning inputs...");
        const inputs = document.querySelectorAll("input");
        let cleanedCount = 0;
        inputs.forEach((input) => {
          // Only clear inputs that aren't hints (not colored blue)
          if (input.style.color !== "blue") {
            input.value = "";
            input.style.color = ""; // Reset the color
            cleanedCount++;
          }
        });
        logger.success("Inputs cleaned:", { cleanedCount });
      }

      // Patch console.log to also write to debug pre
      function enableDebugger() {
        const originalLog = console.log;
        console.log = function (...args) {
          // Call original console.log
          originalLog.apply(console, args);

          // Write to debug pre
          const debugPre = document.getElementById("debug");
          if (debugPre) {
            const timestamp = new Date().toLocaleTimeString();
            const message = args
              .map((arg) =>
                typeof arg === "object"
                  ? JSON.stringify(arg, null, 2)
                  : String(arg)
              )
              .join(" ");
            debugPre.innerHTML += `[${timestamp}] ${message}\n`;
            // Auto scroll to bottom
            debugPre.scrollTop = debugPre.scrollHeight;
          }
        };
      }

      // Start a new game when the page loads
      window.onload = newGame;
    </script>
  </body>
</html>
